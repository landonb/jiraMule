#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'
require 'jiraTool'

program :version, '0.0.1'
program :description, %{A collection of things that I do with jira.

Many of which are either big batch operations, or need bits of info from
the command line.  All of which turn out to be better handled as a command
line app.

This very specifically does not try to be a generic jira tool; those exist
already.  Rather this is specific to things I need.
}
global_option '--verbose', 'Be chatty'
global_option '-n', '--dry', "Don't run actions that make changes"
#global_option '--config' # TODO

default_command :help

require 'jiraTool/status'
require 'jiraTool/testReady'
require 'jiraTool/release'
# difference between testReady and release is two things:
# 1. testReady also assigns
# 2. release also transitions
#
# So, merge all that into one command and have the parts be --options; maybe

command :query do |c|
  c.syntax = 'jira query [options] query'
  c.summary = 'Get the keys from a jira query'
  c.description = ''
  c.example 'description', 'command example'
	c.option '-u', '--[no-]assignedSelf', 'Prefix query with assignee test'
	c.option '-p', '--[no-]project', 'Prefix query with project test'
  c.action do |args, options|
    # Do something or c.when_called Jira::Commands::Release
		jira = JiraUtils.new(args, options)
		args.unshift("assignee = #{jira.username} AND") if options.assignedSelf
		args.unshift("project = #{$cfg['.jira.project']} AND") if options.project
		q = args.join(' ')
		issues = jira.getIssues(q)
		keys = issues.map {|item| item['key'] + ' ' + item.access('fields.summary')}
		keys.each {|k| puts k}
  end
end

#  vim: set sw=2 ts=2 :
